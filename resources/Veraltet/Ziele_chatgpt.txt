Das ist ein super spannendes Projekt â€“ ein Vampire Survivors-Ã¤hnliches Spiel im Browser ist ambitioniert, aber mit klarer Struktur und Arbeitsteilung absolut machbar.
Ziel ist es, dass ihr lange unabhÃ¤ngig voneinander arbeiten kÃ¶nnt, aber trotzdem ein gemeinsames, gut integrierbares Spiel entsteht.

â¸»

ğŸ¯ Gesamtidee

Ein Top-Down Survival-Spiel, bei dem der Spieler automatisch angreift, Gegner in Wellen erscheinen, XP und Items sammelt, Waffen kombiniert und sich verbessert.

â¸»

âš™ï¸ Technologien
	â€¢	HTML â†’ SpielflÃ¤che (Canvas), UI, Layout
	â€¢	CSS â†’ Stil, Animationen, Responsive Design
	â€¢	JavaScript â†’ Spielmechanik, Logik, Rendering, Physik

â¸»

ğŸ‘¥ Teamaufteilung

Wir strukturieren es in 3 Hauptbereiche, die weitgehend unabhÃ¤ngig voneinander entwickelt werden kÃ¶nnen:

ğŸ§  Person 1 â€“ Game Engine & Core Logic

ZustÃ¤ndig fÃ¼r: Spiellogik, Physik, Game Loop, Kollisionen, Gegnerverhalten

Aufgaben:
	1.	Game Loop (Update & Render)
	2.	Entity-System (Spieler, Gegner, Projektile, Items)
	3.	Bewegung & Kollisionserkennung
	4.	Lebenspunkte, Schaden, XP-System
	5.	Gegner-Spawn-System (Wellen)
	6.	Basisstruktur fÃ¼r Waffen & Angriffe

Deliverables:
	â€¢	game.js â†’ EnthÃ¤lt den Game-Loop und Entity-Verwaltung
	â€¢	entities.js â†’ Klassen fÃ¼r Spieler, Gegner, Projektile
	â€¢	Testbare Demo: Spieler kann sich bewegen und Gegner spawnen.

Absprachen mit anderen:
	â€¢	Schnittstellen fÃ¼r UI-Updates (HP, XP, Level)
	â€¢	Event-System (z. B. onLevelUp, onItemPickup)

â¸»

ğŸ¨ Person 2 â€“ Grafik, Animation & UI

ZustÃ¤ndig fÃ¼r: Darstellung, Canvas-Zeichnung, UI, MenÃ¼, HUD

Aufgaben:
	1.	Erstellen oder Einbinden von Spritesheets (Spieler, Gegner, Items, Projektile)
	2.	Implementieren des Rendering-Systems (Zeichenreihenfolge, Layer)
	3.	Animation (Sprite-Wechsel, Laufanimation, Gegnerbewegung)
	4.	BenutzeroberflÃ¤che:
	â€¢	HP-Bar, XP-Bar
	â€¢	Level-Up-AuswahlmenÃ¼ (Items/Waffen wÃ¤hlen)
	â€¢	Pause- und StartmenÃ¼
	5.	CSS-Styling fÃ¼r SpieloberflÃ¤che und MenÃ¼s

Deliverables:
	â€¢	graphics.js â†’ Renderfunktionen
	â€¢	ui.js â†’ HUD und MenÃ¼s
	â€¢	Sprites/Assets-Ordner mit Grafiken
	â€¢	Testbare Demo: Spieler bewegt sich sichtbar, UI zeigt HP & XP an.

Absprachen mit anderen:
	â€¢	Erwartete Datenstruktur fÃ¼r Spielfiguren (player.x, player.y, player.hp, etc.)
	â€¢	Event-Callbacks (z. B. updateHP(newHP))

â¸»

ğŸ§© Person 3 â€“ Waffen-, Item- & Kombinationssystem

ZustÃ¤ndig fÃ¼r: Gameplay-Tiefe, Waffen, Items, Upgrades, Kombinationen

Aufgaben:
	1.	Waffen-Definitionen (z. B. Peitsche, Messer, Feuerball)
	2.	Item-System (Buffs, HP-Regeneration, Bewegungsgeschwindigkeit)
	3.	Kombinationen:
	â€¢	Waffe + Waffe â†’ Neue mÃ¤chtige Version
	â€¢	Item + Item â†’ Passive Effekte
	â€¢	Waffe + Item â†’ Spezielle FÃ¤higkeiten
	4.	XP/Level-System mit AuswahlmenÃ¼ (z. B. 3 zufÃ¤llige Upgrades zur Auswahl)
	5.	Balancing-Parameter (Damage, Range, Cooldown, Drop-Rates)

Deliverables:
	â€¢	weapons.js â†’ Waffenlogik (Update, Attack)
	â€¢	items.js â†’ Passive Boni, Kombinationsregeln
	â€¢	levelup.js â†’ Upgrade-System (GUI-Anbindung an Person 2)
	â€¢	Testbare Demo: Waffen lassen sich upgraden, neue Effekte sichtbar

Absprachen mit anderen:
	â€¢	Zugriff auf Entity-System (um Schaden zu verursachen)
	â€¢	Schnittstelle fÃ¼r visuelle Darstellung (z. B. Projektiltyp â†’ Sprite-ID)

â¸»

ğŸ”— Gemeinsame Strukturen (mÃ¼ssen am Anfang abgestimmt werden)

Einmalig zu dritt absprechen:
	1.	Basis-Ordnerstruktur:

/src
  index.html
  style.css
  /js
    game.js
    entities.js
    graphics.js
    ui.js
    weapons.js
    items.js
    levelup.js
/assets
  /sprites
  /sounds


	2.	Datenobjekte:

player = {
  x: 100,
  y: 100,
  hp: 100,
  maxHp: 100,
  xp: 0,
  level: 1,
  weapons: [],
  items: []
};


	3.	Event-System oder Message Bus:

events.emit('enemyKilled', enemy);
events.on('levelUp', showLevelUpMenu);


	4.	Standardwerte (Balancing-Startwerte):
	â€¢	Spieler HP: 100
	â€¢	Basis-Schaden: 10
	â€¢	XP pro Gegner: 5
	â€¢	Level-Up bei 100 XP

â¸»

ğŸ•“ Zeitplan (empfohlen)

Phase	Dauer	Inhalt	Ziel
1. Planung & Setup	1 Woche	Struktur, Schnittstellen, Dummy-Grafiken	LÃ¤uft lokal, Spiel startet
2. Core Development	2â€“3 Wochen	Jede Person arbeitet an ihrem Modul	Einzel-Demos funktionieren
3. Integration	1 Woche	ZusammenfÃ¼hren der Module	Spielbar, aber unbalanciert
4. Balancing & Polish	1â€“2 Wochen	Grafiken, Sounds, Performance	PrÃ¤sentationsreif


â¸»

ğŸ’¡ Erweiterungsideen (wenn Zeit bleibt)
	â€¢	Partikeleffekte (Blut, Explosionen)
	â€¢	Unterschiedliche Karten
	â€¢	Soundeffekte & Musik
	â€¢	Save/Load-Funktion mit localStorage
	â€¢	Mobile Steuerung
